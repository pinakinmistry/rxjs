<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Reactive Programming Using RxJS</title>
		<meta name="description" content="Why, What and How RxJS with examples and best practices">
		<meta name="author" content="Hakim El Hattab">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/override.css">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h3>Reactive Programming</h3>
          <h1 class="blue">Using RxJS</h1>
          <h4>Why, What and How to RxJS with Examples and Best Practices</h4>
        </section>

				<section>
					<h1 class="blue">Modern Apps</h1>
					<h4>Dynamic Data/Content and Increased Interactivity</h4>
        </section>

        <section>
          <h1 class="blue">User Events</h1>
          <ul>
            <li>Infinite Scrolling</li>
            <li>Switching Views</li>
            <li>Post</li>
            <li>Swipe</li>
            <li>Like</li>
            <li>Comment</li>
            <li>Follow</li>
            <li>Play/Pause</li>
            <li>...</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">System Events</h1>
          <ul>
            <li>Arrival of Data</li>
            <li>Real Time Updates</li>
            <li>Buffering</li>
            <li>Auto Play/Pause</li>
            <li>Online/Offline Switchovers</li>
            <li>Notifications</li>
            <li>Background Processing</li>
            <li>...</li>
          </ul>
        </section>

        <section>
          <h2 class="blue">We are Subscribed as Consumers of</h2>
          <h1>Continuous Content/Events</h1>
          <h4 class="fragment">Examples?</h4>
        </section>

        <section>
          <h2 class="blue">Subscribe by clicking Bell icon</h2>
          <img src="images/Youtube.png" width="1100" height="600" />
        </section>

        <section>
          <h2 class="blue">Apps as State Machine</h2>
          <img src="images/clock.png" width="1100" height="600" />
        </section>

        <section>
          <h2 class="blue">Going from one state to another on events</h2>
          <img src="images/clock-internals.png" width="1100" height="600" />
        </section>

        <section>
          <h2>Modern Apps need</h2>
          <h1 class="blue">Modern Approach</h1>
          <h3>By treating events as continuous observable streams</h3>
        </section>

        <section>
          <h2>We just <em>`subscribe()`</em> to</h2>
          <h1 class="blue"><em>`Observable`</em> streams</h1>
          <h3>and react to <em>`next()`</em> event to handle the change</h3>
        </section>

        <section>
          <h1>What is a stream?</h1>
        </section>

        <section>
          <h1 class="blue"><em>Everything is a Stream!</em></h1>
          <img src="images/everything-is-stream.png" width="1100" height="600" />
        </section>

        <section>
          <h1 class="blue"><em>Everything is a Stream!</em></h1>
          <ul>
            <li>Reading</li>
            <li>Listening</li>
            <li>Thinking</li>
            <li>Understanding</li>
            <li>Doing</li>
            <li>...</li>
          </ul>
          <h2 class="blue fragment"><em>Right Now and in Future</em></h2>
        </section>

        <section>
          <h1 class="blue"><em>Everything is a Stream!</em></h1>
          <ul>
            <li>It's Ongoing</li>
            <li>Untimely</li>
            <li>Short/Long Lived</li>
            <li>Can Interrupt</li>
            <li>Can Terminate</li>
          </ul>
          <h1 class="blue fragment">So Keep Breathing!</h1>
        </section>

        <section>
          <h1 class="blue"><em>Everything is a Stream!</em></h1>
          <ul>
            <li>Data</li>
            <li>Change in Data</li>
            <li>Events</li>
            <li>Errors</li>
          </ul>
          <h2 class="blue">Are Streams too</h2>
        </section>

        <section>
          <img src="img/producer-consumer.jpg" width="1100" height="600" />
        </section>

        <section>
          <h3 class="blue">Paste below code in browser devtools console</h3>
          <pre>
            <code>
document.addEventListener('mouseenter', function () {
    console.log('Mouseenter Event');
});
document.addEventListener('mouseleave', function () {
    console.log('Mouseleave Event');
});
document.addEventListener('click', function () {
    console.log('Click Event');
});
document.addEventListener('mousemove', function () {
    console.log('Mousemove Event');
});
            </code>
          </pre>
        </section>

        <section>
            <h1 class="blue">Imperative vs Declarative Approach</h1>
            <div class="fragment">
              <h3 class="">Imperative focuses more on <em>`how to do`</em></h3>
              <h3 class="blue">Declarative focuses more on <em>`What to do`</em></h3>
            </div>
        </section>

        <section>
          <h3>Declarative Approach hides Implementation Details</h2>
          <h2 class="blue">With High Level Directives on <em>`what to do`</em></h3>
          <h3>Delegating How Part to</h2>
          <h1 class="blue">Library and Framework</h1>
          <h3 class="fragment">Examples?</h3>
        </section>

        <section>
          <h2 class="blue">Declarative Libraries and Frameworks</h2>
          <ul>
            <li>Underscore</li>
            <li>LoDash</li>
            <li>D3</li>
            <li>AngularJS</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">Reactive Approach</h1>
          <div class="fragment">
            <h3>Declarative approach to react to an event by</h3>
            <h2 class="blue">Providing what needs to be done</h2>
            <h3>when that event occurs</h3>
          </div>
        </section>

        <section>
          <h2 class="blue">And then it keeps <em>`Repeating`</em> the same</h2>
          <h3>Whenever that event occurs</h3>
          <h1 class="blue">Making it <em>`Reactive`</em></h1>
          <h3 class="fragment">Examples?</h3>
        </section>

        <section>
          <h2 class="blue">Reactive Libraries and Frameworks</h2>
          <ul>
            <li>React</li>
            <li>Angular</li>
            <li>VueJS</li>
            <li>Angular Firebase</li>
            <li>NgRx</li>
            <li class="fragment">RxJS</li>
          </ul>
        </section>

        <section>
          <h1>RxJS</h1>
          <h2 class="blue">Reactive Extensions for JavaScript</h2>
          <h3>Utility library for handling streams and events</h3>
          <h1 class="blue">In Reactive Way</h1>
        </section>

        <section>
          <h2 class="blue">Why learn RxJS?</h2>
          <h3>Imperative approach to handle streams is difficult</h3>
          <h3>Asynchronous and Continuous nature of streams causes</h3>
          <h1 class="blue">Chaos in Code</h1>
        </section>

        <section>
          <h3 class="blue">Even chaos has some patterns</h2>
          <h3>RxJS provides operators to handle these patterns</h3>
          <h2 class="blue">Reason why RxJS is embedded in Angular</h2>
        </section>

        <section>
          <h3 class="blue">Reactive Components in Angular</h2>
          <ul>
            <li>ActivatedRoute</li>
            <li>Params</li>
            <li>Form</li>
            <li>Http</li>
            <li>HttpClient</li>
            <li>Angular Firebase</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">RxJS Live</h1>
          <h2>Conference Dedicated to RxJS</h2>
          <h2 class="blue fragment">Look Ma what I found, RxJS!</h2>
        </section>

        <section>
          <h3 class="blue">Drawbacks of Imperative/non Reactive Approach</h3>
          <ul>
            <li>Sharing data/state and its ownership</li>
            <li>Copying data/state locally</li>
            <li>Local updates not propogated to other consumers</li>
            <li>Additional listeners to update local state</li>
            <li>State ownership not defined</li>
            <li>Global event bus</li>
            <li>Public emitters of data</li>
            <li>Timing issue; notifying consumers before they are subscribed</li>
            <li>Sequencing issue</li>
            <li>Low data encapsulation</li>
            <li>Low cohesion</li>
            <li>High coupling</li>
            <li>Strange side effects</li>
            <li>Spaghetti code</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">Unpredictable Behavior</h1>
        </section>

        <section>
          <h1 class="blue">Lessons ToDo App</h1>
          <h3>Using Imperative Approach with</h2>
          <h2 class="blue">Global Event Bus</h2>
        </section>

        <section>
          <img src="img/lessons-todo-app.jpg" width="1100" height="600" />
        </section>

        <section>
          <h2 class="blue">Producer</h2>
          <ul class="left">
            <li>EventBusExperimentsComponent</li>
          </ul>
          <h2 class="blue">Consumers</h2>
          <ul class="left">
            <li>LessonsListComponent</li>
            <li>LessonsCounterComponent</li>
          </ul>
        </section>

        <section>
          <pre>
            <code>
// event-bus-experiments.component.html
//
<div class="course-container">

    <h2> Event Bus Experiments</h2>

    <lessons-counter></lessons-counter>

    <lessons-list></lessons-list>

    <input #input />

    <button class="button button-highlight"

(click)="addLesson(input.value)">Add Lesson</button>
</div>
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// lesson.ts
//
export interface Lesson {
  id: number;
  description: string;
  duration?: string;
  completed?: boolean;
}
            </code>
          </pre>
        </section>

        <section>
          <img src="img/subject-observer.jpg" width="1100" height="600" />
        </section>

        <section>
          <pre>
            <code>
// eventbus.service.ts
//
export interface Observer {
  // Get notified with new data
  notify(data:any);
}

interface Subject {
  // Accepts an eventType and observer that needs to be notified on that event
  subscribeObserver(eventType:string, obs:Observer);

  // Accepts an observer that no longer needs to be notified on given eventType
  unsubscribeObserver(eventType:string, obs:Observer);

  // Notifies all observers of given eventType with given data
  notifyObservers(eventType:string, data:any);
}
            </code>
          </pre>
        </section>

        <section>
            <pre>
              <code>
  // eventbus.service.ts
  //
  ...
  class EventBus implements Subject {

    // Mapping of event type and list of observers subscribed to it
    private observers : {[key:string]: Observer[]} = {};

    // Maintains list of all observers of given eventType
    subscribeObserver(eventType:string, obs: Observer) {
        this.observersPerEventType(eventType).push(obs);
    }

    // Removes given observer from the list of given eventType
    unsubscribeObserver(eventType:string, obs: Observer) {
        const newObservers = _.remove(
            this.observersPerEventType(eventType), el => el === obs );
        this.observers[eventType] = newObservers;
    }

    // Notifies all observers of given eventType with new data
    notifyObservers(eventType:string, data: any) {
        this.observersPerEventType(eventType)
            .forEach(obs => obs.notify(data));
    }

    // Returns list of observers for given eventType
    private observersPerEventType(eventType:string): Observer[] {
        const observersPerType = this.observers[eventType];
        if (!observersPerType) {
            this.observers[eventType] = [];
        }
        return this.observers[eventType];
    }
}

// Make Event Bus globally available to other parts of application
export const globalEventBus = new EventBus();
              </code>
            </pre>
          </section>

          <section>
            <h2 class="blue">Problems in Individual Components</h2>
            <ul>
              <li>Local state</li>
              <li>Local state initialization</li>
              <li>Local state updates/mutations</li>
              <li>Notifying updates to other components</li>
              <li>Sharing state by reference</li>
              <li>Updates shared without notification</li>
              <li>No clear data ownership</li>
              <li>Low cohesion</li>
              <li>High coupling</li>
            </ul>
          </section>

          <section>
            <pre>
              <code>
// event-bus-experiments.component.ts
//
export class EventBusExperimentsComponent implements OnInit {

    // Local copy of lessons (local state)
    lessons: Lesson[] = [];

    ngOnInit() {
        // Initialize state
        this.lessons = testLessons;

        // Notify all subscribed observers about lessons just initialized
        // Note that testLessons is notified to all observers
        // by reference instead of by value
        // This causes tight coupling and side effects
        globalEventBus.notifyObservers(LESSONS_LIST_AVAILABLE,
            testLessons);

        setTimeout(() => {
            // Mock new lesson sent by backend
            // Local state updated and notified to all subscribed observers
            this.lessons.push({
                id: Math.random(),
                description: 'New lesson arriving from backend'
            });
            // LessonsListComponents and LessonsCounterComponent gets notified
            // even if we comment out below line because it is using reference
            // to EventBusExperimentsComponent's lessons in its notify method
            globalEventBus.notifyObservers(LESSONS_LIST_AVAILABLE, this.lessons);
        }, 5000);
    }

    addLesson(lessonText: string) {
        // Notifying new data to all subscribed observers
        globalEventBus.notifyObservers(ADD_NEW_LESSON, lessonText);
    }
}
              </code>
            </pre>
          </section>

          <section>
              <pre>
                <code>
  // lessons-counter.component.ts
  //
  export class LessonsCounterComponent implements Observer {

      // Local state
      lessonsCounter = 0;

      constructor() {
          // Subscribe to initial list of lessons
          globalEventBus.subscribeObserver(LESSONS_LIST_AVAILABLE, this);

          // Subscribe to new lesson being added in future
          // to update the local lessons list
          globalEventBus.subscribeObserver(ADD_NEW_LESSON, {
              notify: lessonText => this.lessonsCounter += 1
          } );
      }

      notify(data: Lesson[]) {
          // Update the counter based on new state
          this.lessonsCounter = data.length;
      }
  }
                </code>
              </pre>
            </section>

          <section>
            <pre>
              <code>
// lessons-list.component.ts
//
export class LessonsListComponent implements Observer {

    // Local state
    lessons: Lesson[] = [];

    constructor() {
        // Subscribe to initial list of lessons
        globalEventBus.subscribeObserver(LESSONS_LIST_AVAILABLE, this);

        // Subscribe to new lesson being added in future
        // to update the local lessons list
        globalEventBus.subscribeObserver(ADD_NEW_LESSON, {
            notify: lessonText => {
                // this.lessons here is pointing to
                // EventBusExperimentsComponent's lessons (local state)
                // as it is shared by reference
                this.lessons.push({
                    id: Math.random(),
                    description: lessonText
                });
            }
        } );
    }

    notify(data: Lesson[]) {
        // Get notified once Lessons are available
        // Note that data is reference to testLessons
        // from EventBusExperimentsComponent
        this.lessons = data;
    }

    toggleLessonViewed(lesson:Lesson) {
        // Local updates not notified to subscribed observers
        lesson.completed = !lesson.completed;
    }

    delete(deleted:Lesson) {
        // Local updates not notified to subscribed observers
        _.remove(this.lessons,
            lessons => lesson.id === deleted.id);
    }
}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// lessons-list.component.html
//
<table class="table lessons-list card card-strong">
    <tbody>
        <tr *ngFor="let lesson of lessons">
            <td class="viewed">
                <input [checked]="lesson.completed" type="checkbox"
                    (click)="toggleLessonViewed(lesson)">
            </td>
            <td class="lesson-title" [ngClass]="{'lesson-viewed':lesson.completed}">
                {{ lesson.description }}
            </td>
            <td class="duration">
                <i class="md-icon duration-icon">access_time</i>
                <span>{{lesson.duration}}</span>
            </td>
            <td>
                <button class="button button-highlight"(click)="delete(lesson)">X</button>
            </td>
        </tr>
    </tbody>
</table>
              </code>
            </pre>
          </section>

          <section>
            <h4 class="blue">EventBusExperimentsComponent and LessonsListComponent</h4>
            <ul>
              <li>Mutating Shared State</li>
              <li>Mixed data ownership</li>
              <li>Tight Coupling</li>
              <li>Spaghetti Code</li>
              <li>Hard to Predict Side Effects</li>
            </ul>
          </section>

          <section>
            <h2 class="blue">Reactive Approach Using Streams</h2>
            <h4>Updating state and notifying observers should be</h4>
            <h1 class="blue">Private to Data Owner</h1>
            <h4>Separating the ability of emitting new data from subcribe/unsubscribe</h4>
          </section>

          <section>
            <h2 class="blue">Subject, Observable and Observer</h2>
            <ul>
              <li><em>`Subject`</em> is private interface for producer to emit data/notify observers</li>
              <li><em>`Observable`</em> is public interface for observers to subscribe/unsubscribe</li>
              <li><em>`Observer`</em> is consumer of data/event emitted by Subject</li>
            </ul>
          </section>

          <section>
            <pre>
              <code>
// Consumer
//
export interface Observer {
  next(data: any);
  complete();
  error();
}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// Public stream
export interface Observable {
  subscribe(obs: Observer);
  unsubscribe(obs: Observer);
}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// Subject is a producer of data/event.
// It is private so that only owner of data can emit new data and notify observers
// It extends both Observer and Observable so that it can
// produce/emit new data or event privately using `next()`
// and provides a public interface to `Observers` to subscribe and unsubscribe.
//
interface Subject extends Observer, Observable  {
}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// app-data.service.ts
//
class SubjectImplementation implements Subject {
    private observers: Observer[] = [];

    subscribe(obs: Observer) {
        this.observers.push(obs);
    }

    unsubscribe(obs: Observer) {
        _remove(this.observers, el => el === obs);
    }

    next(data: any) {
        this.observers.forEach(obs => obs.next(data));
    }
}

// Initialization of lessons private to this service
const lessons: Lesson[] = [];

// lessonsListSubject is private in this service
// so that no other component can emit data using next()
const lessonsListSubject = new SubjectImplementation();

// Public Observable
// Note how public subscribe and unsubscribe of Observable is
// calling private subscribe and unsubscribe of Subject
// This is how we hide the data ownership in Subject
// using Observable as its public interface
export const lessonsList$: Observable = {
    subscribe: obs => {
        lessonsListSubject.subscribe(obs);
        // Notify late subscribers with current data
        obs.next(lessons);
    },
    unsubscribe: obs => lessonsListSubject.subscribe(obs),
};

// Populate and Notify
export function initializeLessonsList(newList: Lesson[]) {
    // Deep cloning newList to avoid unintentional
    // sharing of list with component
    lessons = _.cloneDeep(newList);
    // Notify all observers about new lessons list
    lessonsListSubject.next(lessons);
}
              </code>
            </pre>
          </section>

          <section>
            <h1 class="blue">Encapsulating in Data Store</h1>
          </section>

          <section>
            <pre>
              <code>
// app-data.service.ts
//
class DataStore {
  private lessons: Lesson[] = [];
  private lessonsListSubject = new SubjectImplementation();

  public lessonsList$: Observable = {
      subscribe: obs => {
          this.lessonsListSubject.subscribe(obs);
          obs.next(this.lessons);
      },
      unsubscribe: obs => this.lessonsListSubject.subscribe(obs),
  };

  // Broadcast every mutation
  public initializeLessonsList(newList: Lesson[]) {
      this.lessons = _.cloneDeep(newList);
      this.broadcast();
  }

  public addLesson(newLesson: Lesson) {
      this.lessons.push(_.cloneDeep(newLesson));
      this.broadcast();
  }

  public toggleLesson(toggled: Lesson) {
      const lesson = _.find(this.lessons, lesson => lesson.id === toggled.id);
      lesson.completed != lesson.completed;
      this.broadcast();
  }

  public deleteLesson(deleted: Lesson) {
      _.remove(this.lessons, lesson => lesson.id === deleted.id);
      this.broadcast();
  }

  // Common broadcast method
  private broadcast() {
      this.lessonsListSubject.next(this.lessons);
  }
}

export const store = new DataStore();
              </code>
            </pre>
          </section>

          <section>
            <h1 class="blue">Using store in Components</h1>
          </section>

          <section>
            <pre>
              <code>
// event-bus-experiments.component.ts
//
import {store} from "./app-data.service";

export class EventBusExperimentsComponent implements OnInit {

    ngOnInit() {
        // Notify all observers about Lessons
        store.initializeLessonsList(testLessons);

        setTimeout(() => {
            const newLesson = {
                id: Math.random(),
                description: 'New lesson arriving from backend'
            };
            store.addLesson(newLesson);
        }, 5000);
    }

    addLesson(lessonText: string) {
        store.addLesson(newLesson);
    }
}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// lessons-counter.component.ts
//
import {store, Observer} from "../event-bus-experiments/app-data.service";

// Implements Observer to get notified about next data
export class LessonsCounterComponent implements Observer, OnInit {

    lessonsCounter = 0;

    ngOnInit() {
        console.log('lesson list component is subscribeed as observer ..');
        store.lessonsList$.subscribe(this);
    }

    next(data: Lesson[]) {
        console.log('counter component received data ..');
        this.lessonsCounter = data.length;
    }

}
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code>
// lessons-list.component.ts
//
import {store, Observer} from "../event-bus-experiments/app-data.service";

// Implements Observer to get notified about next data
export class LessonsListComponent implements Observer, OnInit {

    lessons: Lesson[] = [];

    ngOnInit() {
        store.lessonsList$.subscribe(this);
    }

    next(data: Lesson[]) {
        this.lessons = data;
    }

    toggleLessonViewed(lesson:Lesson) {
        store.toggleLesson(lesson);
    }

    delete(lesson:Lesson) {
        store.deleteLesson(lesson);
    }
}
              </code>
            </pre>
          </section>

          <section>
            <h1 class="blue">Store as Observable</h1>
            <h3>By implementing Observable interface</h3>
          </section>

          <section>
            <pre>
              <code>
// app-data.service.ts
//
class DataStore implements Observable {
    private lessons: Lesson[] = [];
    private lessonsListSubject = new SubjectImplementation();

    subscribe(obs: Observer) {
        this.lessonsListSubject.subscribe(obs);
        obs.next(this.lessons);
    }

    unsubscribe(obs: Observer) {
        this.lessonsListSubject.subscribe(obs);
    }

    // ...
}

export const store = new DataStore();
              </code>
            </pre>
          </section>

          <section>
            <h1 class="blue">Updating Components</h1>
          </section>

          <section>
            <pre>
              <code>
// Any Components
//
// ...
// Change below
store.lessonsList$.subscribe(this);
// to
store.subscribe(this);
              </code>
            </pre>
          </section>

          <section>
            <h3>Replacing custom implementation with</h3>
            <h1 class="blue">RxJS Library</h1>
          </section>

          <section>
            <pre>
              <code>
// app-data.service.ts
//
import {BehaviorSubject, Observable, Observer} from 'rxjs';

class DataStore {
    // No need of local state as the state can be maintained in the
    // BehaviorSubject itself as it remembers the last emitted value.
    // private lessons: Lesson[] = [];
    private lessonsListSubject = new BehaviorSubject([]);

    public lessonsList$: Observable<Lesson[]> = lessonsListSubject.asObservable();

    public initializeLessonsList(newList: Lesson[]) {
        this.lessons = _.cloneDeep(newList);
        this.broadcast();
    }

    public addLesson(newLesson: Lesson) {
        const lessons = this.cloneLessons();
        lessons.push(_.cloneDeep(newLesson));
        this.lessonsListSubject.next(lessons);
    }

    public toggleLesson(toggled: Lesson) {
        const lessons = this.cloneLessons();
        const lesson = _.find(lessons, lesson => lesson.id === toggled.id);
        lesson.completed != lesson.completed;
        this.lessonsListSubject.next(lessons);
    }

    deleteLesson(deleted: Lesson) {
        const lessons = this.cloneLessons();
        _.remove(lessons, lesson => lesson.id === deleted.id);
        this.lessonsListSubject.next(lessons);
    }

    private cloneLessons() {
        return _.cloneDeep(this.LessonsListSubject.getValue());
    }
}

export const store = new DataStore();
            </code>
          </pre>
        </section>

        <section>
          <h1 class="blue">Updating Components</h1>
        </section>

        <section>
          <pre>
            <code>
import {Observer} from 'rxjs';

class LessonsListComponent implements Observer<Lesson[]>, OnInit {
    ...
    next(data: Lesson[]) {
        ...
    }

    complete() { ... }

    error(err: any) { ... }
}
            </code>
          </pre>
        </section>

        <section>
          <h1 class="blue">More Reactive Patterns</h1>
          <ul>
            <li>Stateless Service</li>
            <li>Stateless Component</li>
            <li>Observable Service</li>
            <li>Pagination</li>
            <li>Master Details</li>
            <li>Error Handling</li>
            <li>Data Pre Fetching</li>
            <li>Pre Save Forms</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">Problems with Services</h1>
          <ul>
            <li>Maintaining local state</li>
            <li>Nested subscriptions due to nested async event handling/API calls</li>
            <li>Maintaining subscriptions and later unsubscribe them</li>
            <li>Long lived observables causing memory leaks</li>
          </ul>
        </section>

        <section>
          <h1 class="blue">Stateless Service</h1>
          <ul>
            <li>No local state</li>
            <li>No subscription</li>
            <li>Return observables directly instead of subscribing</li>
            <li>Short lived observable by unsubscribing using <em>`first()`</em></li>
            <li>Avoid multiple calls to observable <em>`publishLast().refCount()`</em></li>
          </ul>
        </section>

        <section>
          <pre>
            <code>
// courses.service.ts
//
@Injectable()
export class CoursesService {
    // No Local State
    // No Local Observable

    constructor(private db: AngularFirebaseDatabase) {}

    getAllCourses(): Observable<Course[]> {
        return this.db.list('courses')
            // Unsubscribe after first notification using first()
            .first()
            .do(console.log);
    }

    getLatestLessons(): Observable<Lesson[]> {
        return this.db.list('lessons', {
            query: {
                orderByKey: true,
                limitToLast: 10
            }
        })
        // Unsubscribe after first notification using first()
        .first()
        .do(console.log);
    }

    findCourseByUrl(courseUrl: string): Observable<Course> {
        return this.db.list('courses', {
            query: {
                orderByChild: 'url',
                equalTo: courseUrl
            }
        })
        .first()
        .map(data => data[0]);
    }

    findLessonsForCourse(courseId: string): Observable<Lesson[]> {
        this.db.list('lessons', {
            query: {
                orderByChild: 'courseId',
                equalTo: courseId
            }
        })
        .first();
    }
}
            </code>
          </pre>
        </section>

        <section>
          <h1 class="blue">Stateless Components</h1>
          <ul>
            <li>No local state</li>
            <li>No subscription</li>
            <li>Injects stateless services to make observables available to view template</li>
            <li>Auto subscribe to these observables using async pipes</li>
            <li>Use <em>`async as`</em> syntax to avoid multiple pipes and subcriptions</li>
            <li>Plugging streams of data with view using async pipes</li>
          </ul>
        </section>

        <section>
          <pre>
            <code>
// home.component.ts
//
export class HomeComponent implements OnInit {

  // No Local States
    // Only Local Observables
    courses$: Observable<Course[]>;
    latestLessons$: Observable<Lesson[]>;

    constructor(private coursesService: CoursesService) {}

    ngOnInit() {
        this.courses$ = this.coursesService.getAllCourses();
        this.latestLessons$ = this.coursesService.getLatestLessons();
    }
}
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// home.component.html
//
<div class="screen-container">
    <h2>Stateless Component using Stateless Service</h2>

    <table class="courses-list card card-strong"
        *ngIf="courses$ | async as courses else loadingCourses">
        <tr class="course-summary" *ngFor="let course of courses">
            <td>
                {{course.description}}
            </td>
            <td>
                <button class="button button-primary" [routerLink]="['/course', course.url]">
                    View
                </button>
            </td>
        </tr>
    </table>

    <ng-template #loadingCourses>
        <div>Loading...</div>
    </ng-template>

    <h2>Latest Lessons</h2>

    <table class="lessons-list card card-strong"
        *ngIf="latestLessons$ | async as lessons else loadingLessons">
        <tr class="course-summary" *ngFor="let course of lessons">
            <td>
                {{course.description}}
            </td>
            <td>
                <button class="button button-primary" [routerLink]="['/course', course.url]">
                    View
                </button>
            </td>
        </tr>
    </table>

    <ng-template #loadinglessons>
        <div>Loading...</div>
    </ng-template>
</div>
            </code>
          </pre>
        </section>

        <section>
          <h1 class="blue">Observable Service</h1>
          <h3>Some times we do need state in service</h3>
          <h2 class="blue">in form of <em>`Observable`</em></h2>
          <h3>that other components can subscribe to</h3>
          <h3 class="blue fragment">Example?</h3>
        </section>

        <section>
          <h3 class="blue">Logged In User as Observable</h3>
          <img src="img/logged-in-user-ui.jpg" width="1100" height="700" >
        </section>

        <section>
          <pre>
            <code>
// user.ts
//
export interface User {
    firstName: string;
    lastName?: string;
}
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// user.service.ts
//
export const UNKNOWN_USER: User = {
    firstName = 'Unknown',
};

export class UserService {

    // Private Subject
    private subject = new BehaviorSubject(UNKNOWN_USER);
    // Public Observable
    user$: Observable<User> = this.subject.asObservable();

    constructor(private http: Http) {}

    login(email: string, password: string): Observable<User> {
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');
        return this.http.post('/api/login', {
            email,
            password,
        })
        .map(res => res.json())
        .do(user => this.subject.next(user))
        // Avoid multiple calls by ensure observable completes first
        // before emitting the value
        .publishLast().refCount();
    }
}
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// top-menu.component.ts
//
export class TopMenuComponent implements OnInit {

    isUserLoggedIn$: Observable<boolean>;

    constructor(private userService: UserService) {}

    ngOnInit() {
        this.isUserLoggedIn$ = this.userService.user$
            .map(user => user !== UNKNOWN_USER);
    }
}
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// top-menu.component.html
//
<header class="l-header">
    <ul class="top-menu disable-link-styles">
        <li>
            <a routerLink="home" routerLinkActive="menu-active">Home</a>
        </li>
        <li *ngIf="!(isUserLoggedIn$ | async)">
            <a routerLink="login" routerLinkActive="menu-active">Home</a>
        </li>
        <li *ngIf="(isUserLoggedIn$ | async)">
            <a (click)="logout()">Logout</a>
        </li>
    </ul>
</header>
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// course-detail.component.html
//
<div class="screen-container">

    <course-detail-header
        [course]="course"
        [lessons]="lessons"
        [firstName]="(userService.$user | async).firstName"
        (subscribe)="onSubscribe($event)"
    ></course-detail-header>

    <table class="lessons-list card card-strong"
        *ngIf="latestLessons$ | async as lessons else loadingLessons">
        <tr class="lesson-summary" *ngFor="let lesson of lessons">
            <td>
                {{lesson.description}}
            </td>
            <td>
                <i class="md-icon duration-icon">access_time</i>
                <span>{{lesson.duration}}</span>
            </td>
        </tr>
    </table>

    <ng-template #loadinglessons>
        <div>Loading...</div>
    </ng-template>
</div>
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// course-detail.component.ts
//
export class CourseDetailComponent implements OnInit {

    //Still Local State
    course: Course;
    lessons: Lesson[];

    constructor(
        private route: ActivatedRoute,
        private coursesService: CoursesService,
        private newsLetterService: NewsLetterService,
        private userService: UserService,
    ) {}

    ngOnInit() {
        // Nested Subscriptions
        route.params
            .subscribe(params => {
                this.coursesService.findCourseByUrl(params['id'])
                    .subscribe(data => {
                        this.course = data;
                        this.courseService.findLessonsForCourse(this.course.id)
                            .subscribe(data => this.lessons = data);
                    });
            });
    }

    onSubscribe(email: string) {
        this.newsLetterService.subscribeToNewsLetter(email)
            .subscribe(
                () => alert('Subscription successful'),
                console.error
            );
    }

}
            </code>
          </pre>
        </section>

        <section>
          <pre>
            <code>
// login.component.ts
//
export class LoginComponent implements OnInit {

    constructor(
      private userService: UserService,
      private router: Router
    ) {}

    login(email: string, password: string) {
        this.userService.login(email, password)
            .subscribe(
                () => this.router.navigateByUrl('/home'),
                console.error
            );
    }
}
            </code>
          </pre>
        </section>

        <section>
          <h3>Avoid Nested Subscription using</h3>
          <h1 class="blue"><em>`switchMap()`</em></h1>
        </section>

        <section>
          <pre>
            <code>
// course-detail.component.ts
//
export class CourseDetailComponent implements OnInit {

    //Local Observable
    course$: Observable<Course>;
    lessons$: Observable<Lesson[]>;

    constructor(
        private route: ActivatedRoute,
        private coursesService: CoursesService,
        private newsLetterService: NewsLetterService,
        private userService: UserService,
    ) {}

    ngOnInit() {
        // Avoid Nested Subscriptions using switchMap
        this.course$ = this.route.params
            .switchMap(params => this.coursesService.findCourseByUrl(params['id']))
            .first()
            .publishLast().refCount();

        this.lessons$ = this.course
            .switchMap(course => this.coursesService.findLessonsForCourse(course.id))
            .first()
            .publishLast().refCount();
    }

    onSubscribe(email: string) {
        this.newsLetterService.subscribeToNewsLetter(email)
            .subscribe(
                () => alert('Subscription successful'),
                console.error
            );
    }

}
            </code>
          </pre>
        </section>

        <!-- <section>
          <h2>Bleeding Edge!</h2>
          <h2 class="blue fragment">There will be Blood!</h2>
        </section> -->

				<!-- <section>
					<h1><i><b class="blue">$Q</b></i>: Perk</h2>
						<span>
							<img width="600" height="200" src="images/perk.jpeg" />
						</span>
					</h1>
        </section> -->

        <section>
          <h2 class="blue">References:</h2>
          <ul>
            <li>
              <a href="http://facebook.github.io/graphql/">
                http://facebook.github.io/graphql/
              </a>
            </li>
            <li>
              <a href="https://www.howtographql.com">
                https://www.howtographql.com/
              </a>
            </li>
            <li>
              <a href="https://www.graphql.com/">
                https://www.graphql.com/
              </a>
            </li>
            <li>
              <a
                href="https://dev-blog.apollodata.com/graphql-over-rest-with-node-heroku-and-apollo-engine-fb8581f8d77f"
                target="_blank">
                TicketMaster example
              </a>
            </li>
            <li>
              <a href="https://www.youtube.com/watch?v=3Rmjqsz-txM">
                JSChannel Talk
              </a>
            </li>
          </ul>
        </section>

        <section>
          <h2 class="blue">Happy GraphQLing</h2>
          <img src="images/thumpsup.gif" width="600" height="500" />
          <h2>@pinakinmistry</h2>
        </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
